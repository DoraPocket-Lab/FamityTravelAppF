import 'dart:io';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:image/image.dart' as img_lib;
import 'package:path_provider/path_provider.dart';

import 'package:family_travel_app/core/firestore_service.dart';
import 'package:family_travel_app/core/logger.dart';
import 'package:family_travel_app/features/expense/data/expense_model.dart';
import 'package:family_travel_app/features/expense/data/expense_category.dart';

// A draft class for adding new expenses, without generated fields
class ExpenseDraft {
  final ExpenseCategory category;
  final double amount;
  final String currency;
  final String? note;

  ExpenseDraft({
    required this.category,
    required this.amount,
    required this.currency,
    this.note,
  });
}

class ExpenseRepository {
  final FirebaseFirestore _firestore;
  final FirebaseStorage _storage;
  final FirestoreService _firestoreService;

  ExpenseRepository({
    FirebaseFirestore? firestore,
    FirebaseStorage? storage,
    FirestoreService? firestoreService,
  })
      : _firestore = firestore ?? FirebaseFirestore.instance,
        _storage = storage ?? FirebaseStorage.instance,
        _firestoreService = firestoreService ?? FirestoreService();

  Stream<List<Expense>> watchExpenses(String planId) {
    return _firestore
        .collection('plans')
        .doc(planId)
        .collection('expenses')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) =>
            snapshot.docs.map((doc) => Expense.fromJson(doc.data())).toList());
  }

  Future<Map<String, String>> _uploadReceipt(String planId, String expenseId, File receiptFile) async {
    final storageRef = _storage.ref();
    final imagePath = 'receipts/$planId/$expenseId.jpg';
    final imageRef = storageRef.child(imagePath);

    // Optimize image before upload
    final image = img_lib.decodeImage(receiptFile.readAsBytesSync());
    if (image == null) {
      throw Exception('Could not decode image');
    }

    // Resize and compress
    final resizedImage = img_lib.copyResize(image, width: 1280, height: (image.height * (1280 / image.width)).round());
    final compressedImageBytes = img_lib.encodeJpg(resizedImage, quality: 80);

    // Save to a temporary file for upload
    final tempDir = await getTemporaryDirectory();
    final tempFile = File('${tempDir.path}/$expenseId.jpg');
    await tempFile.writeAsBytes(compressedImageBytes);

    try {
      await imageRef.putFile(tempFile);
      final imageUrl = await imageRef.getDownloadURL();
      // Assume thumbUrl is generated by Firebase Storage extension
      final thumbUrl = imageUrl; // TODO: Replace with actual thumbUrl from Firebase Storage extension
      return {'imageUrl': imageUrl, 'thumbUrl': thumbUrl};
    } catch (e, st) {
      AppLogger.error('Error uploading receipt', e, st);
      rethrow;
    }
  }

  Future<void> addExpense(String planId, ExpenseDraft draft, {File? receiptFile}) async {
    final expenseId = const Uuid().v4();
    String? imageUrl;
    String? thumbUrl;

    if (receiptFile != null) {
      final urls = await _uploadReceipt(planId, expenseId, receiptFile);
      imageUrl = urls['imageUrl'];
      thumbUrl = urls['thumbUrl'];
    }

    // TODO: Implement server-side FX conversion for jpyAmount
    final jpyAmount = draft.amount; // Stubbed for now

    final newExpense = Expense(
      id: expenseId,
      category: draft.category,
      amount: draft.amount,
      currency: draft.currency,
      jpyAmount: jpyAmount,
      note: draft.note,
      imageUrl: imageUrl,
      thumbUrl: thumbUrl,
      createdAt: DateTime.now(), // Will be overwritten by serverTimestamp
      createdBy: 'TODO_CURRENT_USER_UID', // TODO: Get current user UID
    );

    final batch = _firestore.batch();

    // Add expense document
    batch.set(
      _firestore.collection('plans').doc(planId).collection('expenses').doc(expenseId),
      newExpense.toJson(),
    );

    // Update plan's updatedAt timestamp
    batch.update(
      _firestore.collection('plans').doc(planId),
      {'updatedAt': FieldValue.serverTimestamp()},
    );

    try {
      await batch.commit();
      AppLogger.log('Expense added: $expenseId for plan: $planId');
    } catch (e, st) {
      AppLogger.error('Error adding expense: $expenseId for plan: $planId', e, st);
      rethrow;
    }
  }
}

final expenseRepositoryProvider = Provider<ExpenseRepository>((ref) {
  return ExpenseRepository(
    firestoreService: ref.watch(firestoreServiceProvider),
  );
});


